from enum import Enum
from typing import Dict, Type

from connectors import ProtoConnectors, Connectors
from symmetry.groups import Group, GroupAction


class ConnectorSymmetryGenerator:
    def __init__(self, symmetry_dict: Dict[ProtoConnectors, Group]):
        self.symmetry_dict = symmetry_dict
        self.proto_enum = type(next(iter(symmetry_dict.keys())))
        self.connector_enum = self.generate_connector_enum(
            self.make_enum_name(self.proto_enum), symmetry_dict
        )

    def transform(self, connector, g_action: GroupAction):
        # connectors should transform according to the group that generates them
        # e.g.
        # g generated by Trivial() -> h o g -> g for any h
        # g generated by Z2(tx) ->
        # conjugate g generating connector by g_action
        pass

    @staticmethod
    def make_connector_name(proto_connector: ProtoConnectors, g_action: GroupAction):
        return f"{proto_connector.value}_{g_action.name}"

    @staticmethod
    def make_enum_name(proto_enum: Type[ProtoConnectors]) -> str:
        return f"Sym{proto_enum.__name__}"

    def generate_connector_enum(self, enum_name: str) -> Enum:
        connector_names = set()
        for proto_connector, group in self.symmetry_dict.items():
            connector_names.update(
                {self.make_connector_name(proto_connector, g_action) for g_action in group.get_elements()}
            )
        return Enum(enum_name, {name: name for name in connector_names})

    def get(self, proto_connector: ProtoConnectors, g_action: GroupAction):
        return self.connector_enum(self.make_connector_name(proto_connector, g_action))